The Gaming Room was a company that wanted to contract out the development of a relatively simple game to be distributedfrom a web-based service.

If I had to say I did anything particularly well it would probably be my consideration of the potential user experience. For example noting that, in theory, a leaderboard of some kind would likely be a relatively easy but significant benefit to that user experience.

For me, the most helpful part about working through a design document was simply the benefit of having a template. I suffer heavily from staring blankly at a blank document and trying to think of how I should begin any given assignment, so being given what is essentially a list to fill in greatly benefitted my efficiency.

If I could revise any of my previous work, I would probably focus on changing the way I word sentences and explain ideas. I have tried pretty much since I began writing as a child to fix the way I manage to ramble on about some tangent vaguely related to the subject simply because I like explaining things, as I feel it enhances my own understanding. However, I am also old enough at this point that I feel it is almost stylistic, and would lose a part of feeling like I wrote it without that factor.

I feel like I addressed a user's needs through pretty much everything within the project. Memory and storage effects the user experience, in this case, by making sure that each user in a game is served the same image at the same time, and that the game remains responsive and quick-feeling throughout.

I did most of my design work for the project by essentially building on intuition and thinking of how ideas that came from that would be likely to play out. For example, in my mention of social features in the game, intuitively, social features seem like a fairly obvious thing to add to the game. However, social features, like a friends list or a messaging system, would be essentially meaningless without other structures and features surrounding them, like matchmaking of some kind, so that users will actually be in some kind of contact with users they do not already know beforehand. In this case, intuitively, social features are a good thing to add, but applying logic and experience to the situation, they would be meaningless on their own.


CS-255
DriverPass was a client that wanted a system that would allow users to take practice exams and schedule appointments to practice driving with an instructor in order to reduce the failure rate of first time driver's license test-takers. If I had to say I did something particularly well, it would probably be understanding the sequence of events that are likely to play out when a user tried to use the system. If I were to improve one thing, it would probably be the UML class diagram, though I'm not entirely sure how I would imrpove it; otherwise, I'd have probably done it better in the first place. I interpeted needs and implemented them by considering things like the user needing to be able to make an account, and administrators needing to have control over those accounts afterward. It's important to consider these needs for fairly obvious reasons; a system or program or any tool that doesn't fulfill any sort of need isn't really doing anything but existing. I think my main approach to designing was essentially just considering what it would be like to try and access the system, and going from there. For example, if I were a potential student trying to access the system, I'd think about the process of creating an account, then logging into it, then taking practice exams and scheduling lessons, but if I were thinking about it from an administrator's perspective, I'd think about things like the control over the other accounts, and access to things like diagnostics and metrics. 


CS-300
The problem I was trying to solve in these projects was how to use different data structures in order to eventually sort and print a list of courses. I approached the problem of figuring out which data structure to use by thinking in terms of pros and cons, and using those to eliminate the other two options; I landed on BSTs as the best option because, after thinking about the benefits of each data type, the specific task made BSTs seem the most effective to solve the problem. I overcame any roadblocks by essentially just looking around on the internet for other ways people have solved similar problems, and more-or-less Frankensteining together an amalgamation of different solutions, and then trimming what didn't seem neccessary. These projects have made me significantly more knowledgable and capable of implementing and using different kinds of data structures, and understanding when each kind should be used. The projects did not have any specific impact on the maintainability of my code, but every time I code I believe it gets a little bit better in that regard.


CS-305
Artemis Financial was a consulting company that developed financial plans for its clients. They wanted to modernize operations, specifically in terms of its software security. 
I think my biggest strength was in being able to identify potential weaknesses or vulnerabilities in the software. It is important to maintain the security of any codebase because, obviously, the less secure it is, the more frequently it can be exploited, and the more severe those exploits will be. This answer is fairly circular, but, in my opinion, that is because it's pretty fundamental to a system to limit its ability to be used for unintended ends. Having software that is seen as secure helps a company by increasing its clients' trust in that company, as well as being likely to reduce any legal liability if something ends up being secure enough to be up to a legal standard, if not secure enough to prevent an exploit from taking place.
I would say the actual implementation was the most challenging for me, as, for probably the strongest example, I still felt the need to follow almost exactly the given tutorial on carrying out the dependency check, rather than being able to simply do it without a guide any more. Though, that probably had more to do with my own paranoia than any inadequacy on the part of the instruction.
Security was layered by adding multiple instances of different ways of securing different parts of the program. HTTPS was implemented as one layer, being sure that the code itself was secure was another layer, and certificates were another layer, for a few examples. I would likely continue to use the dependency check system as used in the course in the future, but I am confident enough in the idea that similar systems exist for things like other languages that I won't even google it to be sure and accept it as probably true; therefore, I would probably use those, as well.
I checked to be sure the code was functional by, fairly obviously, running it and seeing if it produced the desired result, then, if it did not, I tried to figure out what I did to make the program produce the given result, instead. To be sure of its security, I tried to code in a way that would be as difficult as possible to exploit, while also trying to keep it from impacting normal use in a negative way. For checking for new vulnerabilities after a change in the code, I typically re-ran the vulnerability check.
The biggest resource continues to be googling any issue that arises, as it is very likely that any issue that I came across, someone else has also run into something at least similar enough that a solution can be adapted from them.


CS-320
To make sure code is functional and secure, it needs to be tested, through unit testing, integration testing, and system testing at minimum, with any further testing being even better. These tests should help a programmer find vulnerabilities, like non-validated inmputs and unencrypted data.

Interpreting user needs is best done by keeping the actual interpretation to a minimum, the person gathering the requirements should ask every relevant question he or she can think of, while always doing his or her best to try and think from the user's perspective. Then, once these requirements are as boiled-down as possible, create features of the program for those requirements to be fulfilled.

The most important thing to keep in mind when designing software is to keep a clear, identifiable goal in mind for that software. 
